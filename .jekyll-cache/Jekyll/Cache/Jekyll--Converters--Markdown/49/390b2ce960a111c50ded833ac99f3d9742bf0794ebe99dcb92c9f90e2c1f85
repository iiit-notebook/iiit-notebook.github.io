I"ö<h2 id="layout-of-a-c-program">Layout of a C program</h2>

<ul>
  <li>Every C program is a collection of .c and .h files.</li>
  <li>Each file is a collection of functions.</li>
  <li>Every function is a collection of statements.</li>
  <li>Every statement is a series of tokens.</li>
</ul>

<p>Tokens are (bla bla). The amount of space between tokens usually is not important, as long as they do not get merged together. The compiler ignores excess whitespace.
However putting a newline character in a string literal is illegal</p>
<pre><code class="language-C">printf("To C, or not to C:
that is the question.\n");
/***WRONG***/
</code></pre>

<h2 id="ascii-and-characters">ASCII and characters</h2>

<p>Look at the below code:</p>
<pre><code class="language-C">#include&lt;stdio.h&gt;
int main()
{
    char letter = 'A';
    printf("%c -- %d", letter, letter);	    //Output: A -- 65
    return 0;
}
</code></pre>
<p>So here, the <code class="language-plaintext highlighter-rouge">%c</code> placeholder prints the character, and the <code class="language-plaintext highlighter-rouge">%d</code> placeholder prints the ASCII value of the character. This is because in memory, â€˜Aâ€™ is encoded as 65 (in binary). The place holder just changes the <em>way</em> those bytes are interpreted, as an ASCII code for a character, or as an integer itself.
Now, obviously it can be troublesome if A is output as 65 in a program where it wasnâ€™t expected. This is why we must take care of our data types. It is the data type for a variable which tells the compiler how to read that binary encoding in the memory.
We can get some unexpected behaviour from our program if we try to read a float in binary encoding as a decimal, for eg., because these data types are encoded differently.
C does allow for <em>typecasting</em> to convert between different types, but there are rules for that which we will discuss later.</p>

<h2 id="escape-characters">Escape characters</h2>

<p>Often times we want to print special characters such as double quotes, percent symbols etc. in a string literal, without the C compiler considering it as an individual token, but a part of the string.
To do this, we have to use escape sequences in the string. We are already familiar with <code class="language-plaintext highlighter-rouge">\n</code> to signify a newline character, but we also have <code class="language-plaintext highlighter-rouge">\t</code> for tab, <code class="language-plaintext highlighter-rouge">\"</code> to print literal double quotes, <code class="language-plaintext highlighter-rouge">\\</code> to print backslash and so on. If we want to print a percent symbol, we use <code class="language-plaintext highlighter-rouge">%%</code>. 
We can even escape literal newlines in our string literals by adding a backslash before pressing <code class="language-plaintext highlighter-rouge">&lt;Enter&gt;</code>. This can improve readability for very long strings.</p>
<pre><code class="language-C">printf("Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras ac augue vitae velit lacinia pellentesque non eleifend\
	 odio. Fusce feugiat scelerisque dolor, vitae maximus enim sodales sit amet. Nulla non auctor velit. Nunc a \
	dictum felis.");
	/***LEGAL***/
</code></pre>
<p>Now we donâ€™t have to type <code class="language-plaintext highlighter-rouge">printf</code> multiple times!</p>

<h2 id="scanf-and-its-sensitivity-to-data-types">scanf and its sensitivity to data types</h2>

<p>(need to review and experiment some with scanf)
(keyboard buffers and scanf failure?)</p>
:ET