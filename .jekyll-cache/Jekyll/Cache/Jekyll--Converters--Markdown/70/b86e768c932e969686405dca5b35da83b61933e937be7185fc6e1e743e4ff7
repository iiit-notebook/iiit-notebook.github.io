I"A<h1 id="cs0101---computer-programming--lecture-005-22-sep-2020-tuesday">CS0.101 - Computer Programming | Lecture 005, 22 Sep 2020, Tuesday</h1>
<p>with Prof. Suresh Purini</p>

<h2 id="printf-and-scanf">printf and scanf</h2>

<p>The standard C libraries have a few very useful functions, such as <code class="language-plaintext highlighter-rouge">printf</code> and <code class="language-plaintext highlighter-rouge">scanf</code> present in the headerfile <code class="language-plaintext highlighter-rouge">stdio.h</code>. We can use them to print to <code class="language-plaintext highlighter-rouge">stdout</code>, the standard output, and read from <code class="language-plaintext highlighter-rouge">stdin</code> the standard input.</p>

<pre><code class="language-C">int n = 4;
printf("There are %d sheep\n", n);
</code></pre>
<p>In the above line, <code class="language-plaintext highlighter-rouge">printf</code> takes two arguments, a string literal, and an integer variable. In the string literal, <code class="language-plaintext highlighter-rouge">%d</code> is a special placeholder that tells the function that we want it to print the integer variable that we 
have passed along to the function as the next argument over there. We also have an escape sequence <code class="language-plaintext highlighter-rouge">\n</code>, which tells the function to print the newline character i.e. move to the next line.</p>

<pre><code class="language-C">int n;
scanf("%d", &amp;n);
</code></pre>
<p>In this line of code, <code class="language-plaintext highlighter-rouge">scanf</code> takes two arguments, a string literal, and an <em>address</em> for an integer variable. The <code class="language-plaintext highlighter-rouge">%d</code> as the string literal tells <code class="language-plaintext highlighter-rouge">scanf</code> to anticipate an integer being input. The <code class="language-plaintext highlighter-rouge">&amp;</code> is used to get the address of the integer variable, and then <code class="language-plaintext highlighter-rouge">scanf</code> writes the entered variable to the
given address.</p>

<h2 id="macros">Macros</h2>

<p>A macro is basically a piece of code which has been turned into a shortcut and given a name. Whenever that name is used, it gets replaced by the code we have decided for that macro. There are different types, but we’ll keep it simple here.</p>

<pre><code class="language-C">#define PI 3.14
...
    radius = 7;
    printf("The perimeter is %d\n", 2*PI*radius);
...
</code></pre>
<p>In the above code snippet, we use a macro to substitute PI with 3.14. The immediate thought is <em>‘but why?’</em>, and there are a few reasons why this is a good practice:</p>
<ul>
  <li>It improves the readability of the program.</li>
  <li>This allow us to change the value of it easily, which can be very important if for example we have used this value multiple times through our program and we get to know there is a more precise value we can use.</li>
  <li>Since macros are handled by the preprocessor, that means that the macro is replaced <strong>before</strong> compilation, and thus takes up no memory, as opposed to declaring a <code class="language-plaintext highlighter-rouge">const float</code>.</li>
</ul>

<h2 id="more-library-functions-">More library functions: <math.h></math.h></h2>

<p><code class="language-plaintext highlighter-rouge">&lt;math.h&gt;</code> is a great library which contains common mathematical functions, including <code class="language-plaintext highlighter-rouge">floor</code> and <code class="language-plaintext highlighter-rouge">ceil</code> function which allow us to round floating point numbers down and up respectively, into integers. To compile a program containing a function defined in <code class="language-plaintext highlighter-rouge">&lt;math.h&gt;</code>, first we must tell the preprocessor to include it and we must also tell the compiler to link it by using the <code class="language-plaintext highlighter-rouge">-lm</code> flag.
<code class="language-plaintext highlighter-rouge">gcc mathy_code.c -o mathy_code.out -lm</code> allows us to compile our code properly.</p>
:ET